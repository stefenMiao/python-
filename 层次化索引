层次化索引能够在一个轴上拥有多个索引级别，使你能够在低纬度处理高纬度数据
data = pd.Series(np.random.randn(9),
    index=[['a', 'a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],
           [1, 2, 3, 1, 3, 1, 2, 2, 3]])

 data
a  1    0.299899
   2    1.214703
   3    0.034937
b  1    0.583872
   3   -1.459670
c  1    0.215664
   2   -1.230114
d  2   -0.354812
   3   -1.042403
   
data.index
MultiIndex([('a', 1),   #可以看出是层次化索引
            ('a', 2),
            ('a', 3),
            ('b', 1),
            ('b', 3),
            ('c', 1),
            ('c', 2),
            ('d', 2),
            ('d', 3)],
           )

可以使用部分索引选取数据子集
data['a']
1    0.299899
2    1.214703
3    0.034937

data['a':'c']
a  1    0.299899
   2    1.214703
   3    0.034937
b  1    0.583872
   3   -1.459670
c  1    0.215664
   2   -1.230114
   
data.loc[['a','d']]
a  1    0.299899
   2    1.214703
   3    0.034937
d  2   -0.354812
   3   -1.042403  
  
data.loc[:,2]  #也可以在内层提取 
a    1.214703
c   -1.230114
d   -0.354812

unstack方法
将层次化的series重新安排在dataframe中
data.unstack()
          1         2         3
a  0.299899  1.214703  0.034937
b  0.583872       NaN -1.459670
c  0.215664 -1.230114       NaN
d       NaN -0.354812 -1.042403
  
它的逆方法是stack
data==data.unstack().stack()

对于dataframe，每个轴都能有分层索引
frame = pd.DataFrame(np.arange(12).reshape((4, 3)),
     index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
     columns=[['Ohio', 'Ohio', 'Colorado'],
              ['Green', 'Red', 'Green']])

frame
     Ohio     Colorado
    Green Red    Green
a 1     0   1        2
  2     3   4        5
b 1     6   7        8
  2     9  10       11
  
每一层都能有自己的名字
frame.index.names=['key1','key2']
frame.columns.names=['c1','c2']

frame
c1         Ohio     Colorado
c2        Green Red    Green
key1 key2                   
a    1        0   1        2
     2        3   4        5
b    1        6   7        8
     2        9  10       11

可以由列索引选取列分组
frame['Ohio']
c2         Green  Red
key1 key2            
a    1         0    1
     2         3    4
b    1         6    7
     2         9   10


-------------重排与分级排序-------------
swaplevel方法
接受两个级别编号或名称，返回互换级别的对象
frame.swaplevel('key1','key2')   #默认在axis=0轴
c1         Ohio     Colorado
c2        Green Red    Green
key2 key1                   
1    a        0   1        2
2    a        3   4        5
1    b        6   7        8
2    b        9  10       11

frame.swaplevel('c1','c2',axis=1)
c2        Green  Red    Green
c1         Ohio Ohio Colorado
key1 key2                    
a    1        0    1        2
     2        3    4        5
b    1        6    7        8
     2        9   10       11

sort_index方法
可以指定级别进行排序
frame.sort_index(level=1)
c1         Ohio     Colorado
c2        Green Red    Green
key1 key2                   
a    1        0   1        2
b    1        6   7        8
a    2        3   4        5
b    2        9  10       11


----------根据级别汇总统计-----------
对dataframe和series的描述和汇总统计常有level选项，用于指定在某条轴上求和的级别
frame.sum(level='key2')  #默认axis=0
c1    Ohio     Colorado
c2   Green Red    Green
key2                   
1        6   8       10
2       12  14       16
分析：对于key2每一个索引，对索引相同的值求sum

frame.sum(level='c1',axis=1)
c1         Ohio  Colorado
key1 key2                
a    1        1         2
     2        7         5
b    1       13         8
     2       19        11

-----------使用dataframe的列进行索引----------
将dataframe的一个或者多个列当作行索引使用，或者将行索引变为dataframe的列
set_index函数
将其中一个或多个列转换为行索引，返回新的副本
frame
   a  b    c  d
0  0  7  one  0
1  1  6  one  1
2  2  5  one  2
3  3  4  two  0
4  4  3  two  1
5  5  2  two  2
6  6  1  two  3

frame
Out[58]: 
       a  b
c   d      
one 0  0  7
    1  1  6
    2  2  5
two 0  3  4
    1  4  3
    2  5  2
    3  6  1

drop参数
drop=False，保留想要转换为行索引的列
frame2=frame.set_index(['c','d'],drop=False)
       a  b    c  d
c   d              
one 0  0  7  one  0
    1  1  6  one  1
    2  2  5  one  2
two 0  3  4  two  0
    1  4  3  two  1
    2  5  2  two  2
    3  6  1  two  3


reset_index()
set_index的反函数，层次化索引的级别转移到列列里面
frame.reset_index()
   index  a  b    c  d
0      0  0  7  one  0
1      1  1  6  one  1
2      2  2  5  one  2
3      3  3  4  two  0
4      4  4  3  two  1
5      5  5  2  two  2
6      6  6  1  two  3





